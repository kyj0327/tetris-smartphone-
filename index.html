
<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>모바일 테트리스</title>
<style>
  body {margin:0;background:#222;color:#fff;font-family:Arial;display:flex;flex-direction:column;align-items:center;height:100vh;}
  canvas {background:#000;border:2px solid #fff;width:100%;max-width:480px;height:auto;}
  .controls-container {display:flex;justify-content:center;gap:15px;flex-wrap:wrap;padding:15px;background:rgba(0,0,0,0.6);}
  .controls-container button {width:80px;height:80px;font-size:24px;border-radius:50%;border:3px solid #fff;background:#333;color:#fff;}
  .dpad {display:grid;grid-template-areas:". up .""left center right"". down .";gap:10px;}
  #score {margin:10px;font-size:24px;font-weight:bold;}
  #gameOverModal {position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.9);padding:30px;border:2px solid #fff;display:none;text-align:center;}
</style>
</head>
<body>
<canvas id="tetris" width="240" height="400"></canvas>
<div class="controls-container">
  <button onclick="togglePause()">⏸</button>
  <div class="dpad">
    <button style="grid-area: up;" onclick="rotateClock()">▲</button>
    <button style="grid-area: left;" onclick="moveLeft()">◀</button>
    <button style="grid-area: right;" onclick="moveRight()">▶</button>
    <button style="grid-area: down;" onclick="softDrop()">▼</button>
  </div>
  <button onclick="holdBlock()">H</button>
  <button onclick="hardDrop()">↓↓</button>
</div>
<div id="score">점수: 0</div>
<div id="gameOverModal">
  <h1>게임 오버</h1>
  <p id="finalScore"></p>
  <button onclick="restartGame()">재시작</button>
</div>
<script>
const canvas=document.getElementById('tetris');const context=canvas.getContext('2d');context.scale(20,20);
const arena=createMatrix(12,20);let score=0,isPaused=false,gameOver=false;
const player={pos:{x:0,y:0},matrix:null};const colors=[null,'#800080','#FFD700','#FFA500','#0000FF','#008000','#7CFC00','#FF0000'];
function createMatrix(w,h){const m=[];while(h--)m.push(new Array(w).fill(0));return m;}
function createPiece(t){if(t==='T')return[[0,0,0],[1,1,1],[0,1,0]];if(t==='O')return[[2,2],[2,2]];if(t==='L')return[[0,3,0],[0,3,0],[0,3,3]];if(t==='J')return[[0,4,0],[0,4,0],[4,4,0]];if(t==='I')return[[0,5,0,0],[0,5,0,0],[0,5,0,0],[0,5,0,0]];if(t==='S')return[[0,6,6],[6,6,0],[0,0,0]];if(t==='Z')return[[7,7,0],[0,7,7],[0,0,0]];}
function drawMatrix(m,o){m.forEach((r,y)=>r.forEach((v,x)=>{if(v){context.fillStyle=colors[v];context.fillRect(x+o.x,y+o.y,1,1);}});}
function draw(){context.fillStyle='#000';context.fillRect(0,0,canvas.width,canvas.height);drawMatrix(arena,{x:0,y:0});drawMatrix(player.matrix,player.pos);}
function merge(arena,p){p.matrix.forEach((r,y)=>r.forEach((v,x)=>{if(v)arena[y+p.pos.y][x+p.pos.x]=v;}));}
function collide(arena,p){const m=p.matrix,o=p.pos;for(let y=0;y<m.length;y++){for(let x=0;x<m[y].length;x++){if(m[y][x]&&(arena[y+o.y]&&arena[y+o.y][x+o.x])!==0)return true;}}return false;}
function playerDrop(){player.pos.y++;if(collide(arena,player)){player.pos.y--;merge(arena,player);playerReset();arenaSweep();updateScore();if(gameOverCheck())showGameOver();}dropCounter=0;}
function playerHardDrop(){while(!collide(arena,player)){player.pos.y++;}player.pos.y--;merge(arena,player);playerReset();arenaSweep();updateScore();if(gameOverCheck())showGameOver();}
function playerReset(){const pieces='TJLOSZI';player.matrix=createPiece(pieces[Math.floor(Math.random()*pieces.length)]);player.pos.y=0;player.pos.x=(arena[0].length/2|0)-(player.matrix[0].length/2|0);}
function rotate(m,d){for(let y=0;y<m.length;y++){for(let x=0;x<y;x++){[m[x][y],m[y][x]]=[m[y][x],m[x][y]];}}if(d>0)m.forEach(r=>r.reverse());else m.reverse();}
function playerRotate(d){const pos=player.pos.x;let offset=1;rotate(player.matrix,d);while(collide(arena,player)){player.pos.x+=offset;offset=-(offset+(offset>0?1:-1));if(offset>player.matrix[0].length){rotate(player.matrix,-d);player.pos.x=pos;return;}}}
function arenaSweep(){for(let y=arena.length-1;y>=0;y--){if(arena[y].every(v=>v!==0)){arena.splice(y,1);arena.unshift(new Array(arena[0].length).fill(0));score+=10;y++;}}}
function gameOverCheck(){return arena[0].some(v=>v!==0);}
function updateScore(){document.getElementById('score').innerText='점수: '+score;}
function showGameOver(){gameOver=true;document.getElementById('finalScore').innerText='최종 점수: '+score;document.getElementById('gameOverModal').style.display='block';}
function restartGame(){arena.forEach(r=>r.fill(0));score=0;updateScore();playerReset();gameOver=false;document.getElementById('gameOverModal').style.display='none';update();}
let dropCounter=0,dropInterval=1000,lastTime=0;
function update(time=0){if(isPaused||gameOver)return requestAnimationFrame(update);const dt=time-lastTime;lastTime=time;dropCounter+=dt;if(dropCounter>dropInterval)playerDrop();draw();requestAnimationFrame(update);}
update();
/* 모바일 버튼 기능 */
function moveLeft(){if(!isPaused&&!gameOver){player.pos.x--;if(collide(arena,player))player.pos.x++;}}
function moveRight(){if(!isPaused&&!gameOver){player.pos.x++;if(collide(arena,player))player.pos.x--;}}
function softDrop(){if(!isPaused&&!gameOver)playerDrop();}
function rotateClock(){if(!isPaused&&!gameOver)playerRotate(1);}
function hardDrop(){if(!isPaused&&!gameOver)playerHardDrop();}
function holdBlock(){alert('홀드 기능은 현재 미구현');}
function togglePause(){isPaused=!isPaused;}
</script>
</body>
</html>
